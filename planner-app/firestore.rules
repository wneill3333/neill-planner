rules_version = '2';

/**
 * Firestore Security Rules for Neill Planner
 *
 * These rules enforce server-side authorization to ensure:
 * - Users can only access their own data
 * - All operations require authentication
 * - Data validation is enforced at the database level
 */

service cloud.firestore {
  match /databases/{database}/documents {

    // =============================================================================
    // Helper Functions
    // =============================================================================

    /**
     * Check if user is authenticated
     */
    function isAuthenticated() {
      return request.auth != null;
    }

    /**
     * Check if user owns the resource
     */
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    /**
     * Check if user is admin (for future use)
     */
    function isAdmin() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * Check if user's role matches their allowedUsers whitelist entry
     * Used to permit role sync on login (whitelist is source of truth)
     */
    function roleMatchesWhitelist(newRole) {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/allowedUsers/$(request.auth.token.email)) &&
             get(/databases/$(database)/documents/allowedUsers/$(request.auth.token.email)).data.role == newRole;
    }

    /**
     * Validate string length
     */
    function validLength(str, min, max) {
      return str is string && str.size() >= min && str.size() <= max;
    }

    /**
     * Validate task priority
     */
    function validTaskPriority(priority) {
      return priority is map &&
             priority.letter is string &&
             priority.letter in ['A', 'B', 'C', 'D'] &&
             priority.number is int &&
             priority.number >= 1;
    }

    /**
     * Validate task status
     */
    function validTaskStatus(status) {
      return status is string &&
             status in ['in_progress', 'forward', 'complete', 'delete', 'delegate'];
    }

    /**
     * Validate scheduled time format (HH:MM)
     */
    function validScheduledTime(time) {
      return time == null || (time is string && time.matches('^([0-1][0-9]|2[0-3]):[0-5][0-9]$'));
    }

    /**
     * Validate hex color code
     */
    function validColorCode(color) {
      return color is string && color.matches('^#[0-9A-Fa-f]{6}$');
    }

    // =============================================================================
    // Allowed Users Collection (Email Whitelist)
    // =============================================================================

    match /allowedUsers/{email} {
      // Users can read their own entry (by email match)
      // Admins can read all entries
      allow read: if isAuthenticated() &&
                     (request.auth.token.email == email || isAdmin());

      // Admins can create entries; bootstrap: initial admin can create their own entry
      allow create: if isAuthenticated() &&
                       request.resource.data.role in ['standard', 'admin'] &&
                       (isAdmin() ||
                        (request.auth.token.email == 'williamjneill@gmail.com' &&
                         email == 'williamjneill@gmail.com'));

      // Admins can update any entry; users can update their own lastLoginAt only
      allow update: if isAuthenticated() &&
                       request.resource.data.role in ['standard', 'admin'] &&
                       (isAdmin() ||
                        (request.auth.token.email == email &&
                         request.resource.data.role == resource.data.role &&
                         request.resource.data.email == resource.data.email &&
                         request.resource.data.addedBy == resource.data.addedBy));

      // Admins can delete, but not their own entry (self-protection)
      allow delete: if isAdmin() &&
                       request.auth.token.email != email;
    }

    // =============================================================================
    // Users Collection
    // =============================================================================

    match /users/{userId} {
      // Users can read their own profile
      allow read: if isOwner(userId);

      // User creation handled by backend (Firebase Auth trigger)
      allow create: if isOwner(userId) &&
                       request.resource.data.email is string &&
                       request.resource.data.displayName is string &&
                       request.resource.data.role in ['standard', 'admin'];

      // Users can update their own profile (but not role unless it matches whitelist)
      // Admins can update any user's role
      allow update: if (isOwner(userId) && request.resource.data.role == resource.data.role) ||
                       (isOwner(userId) && roleMatchesWhitelist(request.resource.data.role)) ||
                       isAdmin();

      // Only admins can delete users
      allow delete: if isAdmin();
    }

    // =============================================================================
    // User Settings Collection
    // =============================================================================

    match /userSettings/{userId} {
      // Users can read and update their own settings
      allow read, create, update: if isOwner(userId);

      // Users cannot delete settings
      allow delete: if false;
    }

    // =============================================================================
    // Tasks Collection
    // =============================================================================

    match /tasks/{taskId} {
      // Users can read their own tasks
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      // Users can create tasks for themselves
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       validLength(request.resource.data.title, 1, 500) &&
                       (!('description' in request.resource.data) || request.resource.data.description == null || validLength(request.resource.data.description, 0, 5000)) &&
                       validTaskPriority(request.resource.data.priority) &&
                       validTaskStatus(request.resource.data.status) &&
                       validScheduledTime(request.resource.data.get('scheduledTime', null)) &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp;

      // Users can update their own tasks
      // Note: Strict field validation is enforced at the application layer (tasks.service.ts).
      // Rules focus on ownership to avoid rejecting updates on documents with legacy field types.
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;

      // Users can delete their own tasks
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // =============================================================================
    // Categories Collection
    // =============================================================================

    match /categories/{categoryId} {
      // Users can read their own categories
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      // Users can create categories for themselves
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       validLength(request.resource.data.name, 1, 50) &&
                       validColorCode(request.resource.data.color) &&
                       request.resource.data.sortOrder is int &&
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.updatedAt is timestamp;

      // Users can update their own categories
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid &&
                       validLength(request.resource.data.name, 1, 50) &&
                       validColorCode(request.resource.data.color) &&
                       request.resource.data.updatedAt is timestamp;

      // Users can delete their own categories
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // =============================================================================
    // Events Collection (for future implementation)
    // =============================================================================

    match /events/{eventId} {
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;

      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;

      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // =============================================================================
    // Notes Collection (for future implementation)
    // =============================================================================

    match /notes/{noteId} {
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;

      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;

      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // =============================================================================
    // Journals Collection
    // =============================================================================

    match /journals/{journalId} {
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;

      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;

      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // =============================================================================
    // Journal Entries Collection
    // =============================================================================

    match /journalEntries/{entryId} {
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;

      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;

      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // =============================================================================
    // Recurring Patterns Collection
    // =============================================================================

    match /recurringPatterns/{patternId} {
      // Users can read their own recurring patterns
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      // Users can create recurring patterns for themselves
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;

      // Users can update their own recurring patterns
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;

      // Users can delete their own recurring patterns
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // =============================================================================
    // Reminders Collection
    // =============================================================================

    match /reminders/{reminderId} {
      // Users can read their own reminders
      allow read: if isAuthenticated() &&
                     resource.data.userId == request.auth.uid;

      // Users can create reminders for themselves
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid;

      // Users can update their own reminders
      allow update: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid &&
                       request.resource.data.userId == request.auth.uid;

      // Users can delete their own reminders
      allow delete: if isAuthenticated() &&
                       resource.data.userId == request.auth.uid;
    }

    // =============================================================================
    // Google Calendar Credentials Collection
    // =============================================================================

    match /googleCalendarCredentials/{credentialId} {
      // Document ID is the userId, so use credentialId for ownership checks
      allow read: if isOwner(credentialId);
      allow create, update: if isOwner(credentialId);
      allow delete: if isOwner(credentialId);
    }

    // =============================================================================
    // Google Drive Credentials Collection
    // =============================================================================

    match /googleDriveCredentials/{userId} {
      allow read: if isOwner(userId);
      allow create, update: if isOwner(userId) &&
                               request.resource.data.accessToken is string &&
                               request.resource.data.scope is string &&
                               request.resource.data.expiresAt is timestamp;
      allow delete: if isOwner(userId);
    }

    // =============================================================================
    // Default Rule - Deny All
    // =============================================================================

    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
